# 题目：爬楼梯
## 描述
假设你正在爬楼梯。需要 n 阶你才能到达楼顶。

每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？

注意：给定 n 是一个正整数。

示例 1：

输入： 2
输出： 2
解释： 有两种方法可以爬到楼顶。
1.  1 阶 + 1 阶
2.  2 阶
示例 2：

输入： 3
输出： 3
解释： 有三种方法可以爬到楼顶。
1.  1 阶 + 1 阶 + 1 阶
2.  1 阶 + 2 阶
3.  2 阶 + 1 阶

## 解题思路
采用动态规划算法,需确定多个条件：
1. 最优子结构：有些动态规划的题目会最终根据子问题的解中选择一个最优子结构作为最终的解。该题目不涉及选择最优子结构
2. 子问题重叠：动态规划分解后的子问题是和父问题一样的，具有重叠性
3. 边界：每个动态规划都需要设定一个边界条件，不然没有边界就会出现死循环，永远得不到最终解
4. 子问题独立：每个被分离的子问题在解决问题的逻辑上是两两互不影响，具有独立性
5. 做备忘录：在进行子问题的解决过程中，可能会遇到同样的问题，则做下备忘，直接返回答案，不用再重复计算一样的问题                           
    
规定每次只能走1梯或2梯，分析如下：

    边界条件：
    1. 如果只剩下一个楼梯，只有一种走法，则返回： f(1) = 1
    2. 如果只剩下两个楼梯，走法为2种，则返回 : f(2) = 2

    最后一步的走法：按照每次只能走1梯或2梯，最后一步分为走最后1梯和2梯: 
    1、如果有10梯，最后一步走1梯，前9梯有m种走法，则总的走法有f(10) = m
    2、如果有10梯，最后一步走2梯，前8梯有k种走法，则总的走法有f(8) = k
    3、则10梯总的走法为：f(10) = f(9) + f(8) = m + k
    
    总结算式：
    则 f(n) = f(n-1) + f(n-2)

## 代码实现
    public class ClimbStairs70 {
        /**
         * 采用动态规划，实现核心步骤：
         *
         */
        // 备忘录
        Map<Integer,Integer> map = new HashMap<>();
        Integer sum = 0;
        public int climbStairs(int n) {
            if(n==1){
                return 1;
            }
    
            if(n==2){
                return 2;
            }
    
            if(map.containsKey(n)){
                sum = map.get(n);
            }else {
                sum = climbStairs(n - 1) + climbStairs(n - 2);
                map.put(n,sum);
            }
            return sum;
        }
    } 


