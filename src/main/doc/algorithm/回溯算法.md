# 回溯算法
## 介绍
　　根据百度百科介绍：回溯算法实际上一个类似枚举的搜索尝试过程，主要是在搜索尝试过程中寻找问题的解，
当发现已不满足求解条件时，就“回溯”返回，尝试别的路径。**回溯法是一种选优搜索法，按选优条件向前搜索，
以达到目标。但当探索到某一步时，发现原先选择并不优或达不到目标，就退回一步重新选择，这种走不通就退回再走的技术为回溯法**，
而满足回溯条件的某个状态的点称为“回溯点”。
许多复杂的，规模较大的问题都可以使用回溯法，有“通用解题方法”的美称。
## 八皇后问题
　　比较出名的运用回溯法的金典问题是八皇后问题：在8*8的国际象棋中，将八位皇后放在一张8x8的棋盘上，使得每位皇后都无法吃掉别的皇后，
（即任意两个皇后都不在同一条横线，竖线和斜线上），问一共有多少种摆法。

在棋盘中放置一个皇后，其封锁范围如图所示：
![回溯算法-八皇后问题](/src/main/imges/回溯算法-八皇后问题.jpg)

继续添加一个皇后，封锁范围如下图所示：

![八皇后问题-两个皇后](/src/main/imges/八皇后问题-两个皇后.jpg)

如此继续下去，能安放下一位皇后的位置越来越少，那么我们最终如何能安放完这8位皇后呢？回溯
算法就是专门用来解决这类问题的方法。

## 回溯算法解决八皇后问题思路
#### 1. 解决八皇后问题，可以分为两个层面：

- 找出第一种正确摆放方式，也就是深度优先遍历

- 找出全部的正确摆放方式，也就是广度优先遍历：在棋盘中按每行横向移动，找出所有解
　　

#### 2. 回溯递归主要把握三个点：
- 确定解输出的判断条件

　　在八皇后问题中，找到正确解的判断条件是棋盘上成功摆放了8个皇后，反应在程序中就是当行数大于7则
得到了正确的解。

        // 满足条件的解
        if (i > 7) {
            count++;
            printResult();
            // 如果只需要获取一个解，不是所有可能的解，则可以在这里做处理
            // return;
        }
　　
- 进行深层次递归的判断条件

　　在八皇后问题中，判断是否进行下层递归的条件是：皇后落点是否合规，具体为是否满足任意两个
皇后都不在同一条横线，竖线和斜线上。

    public boolean judgeLegal(int i, int j){
        // 判断j列是否有另一个皇后已经落点，只需判断j列0到i行的棋盘落点，相当于array[i][j]位置的竖向正上方的所有位置
        for (int k = 0; k < i; k++) {
            if (array[k][j] == 1) {
                return false;
            }
        }

        // 判断array[i][j]位置左上斜线是否有其它皇后落点
        for (int k = i - 1,p = j - 1;k >= 0 && p >= 0;k--,p--) {
            if (array[k][p] == 1) {
                return false;
            }
        }

        // 判断array[i][j]位置右上斜线是否有其它皇后落点
        for (int k = i -1,p = j + 1;k >= 0 && p < 8;k--,p++) {
            if (array[k][p] == 1) {
                return false;
            }
        }
        return true;
    }

- 下一层递归无解时回溯后，注意回溯点状态的重置

　　在八皇后问题中，如果当前行8个落点都不符合规定，则需回溯到上一层，即当前行的上一行的皇后合规的落点
处，并进行状态重置后，继续当前行向后横向移动寻找合规的落点。

           // 该层循环的意义：为了获取全部的正确解，进行广度优先遍历：在棋盘中按每行横向移动，找出所有解
            for (int k = 0; k < 8; k++) {
                // 进行是否有资格进行下一层次递归的判断
                if (judgeLegal(i, k)) {
                    // 落点合规，设置该回溯点为1
                    array[i][k] = 1;
                    // 进行下一层递归，进行深度优先遍历
                    getResultQueensOfEight(i + 1);
                    // 回溯:寻找其它解，清除状态，设置回溯点状态为0
                    array[i][k] = 0;
                }
            }
 
3. 过程描述
        
        // 核心代码
        public void getResultQueensOfEight(int i){
            // 满足条件的解
            if (i > 7) {
                count++;
                printResult();
                // 如果只需要获取一个解，不是所有可能的解，则可以在这里做处理
                // return;
            }else {
                // 该层循环的意义：为了获取全部的正确解，进行广度优先遍历：在棋盘中按每行横向移动，找出所有解
                for (int k = 0; k < 8; k++) {
                    // 进行是否有资格进行下一层次递归的判断
                    if (judgeLegal(i, k)) {
                        // 落点合规，设置该回溯点为1
                        array[i][k] = 1;
                        // 进行下一层递归，进行深度优先遍历
                        getResultQueensOfEight(i + 1);
                        // 回溯:寻找其它解，清除状态，设置回溯点状态为0
                        array[i][k] = 0;
                    }
                }
            }
        }
        
        // 进行深层次递归的判断：落点是否合规
        public boolean judgeLegal(int i, int j){
            // 判断j列是否有另一个皇后已经落点，只需判断j列0到i行的棋盘落点，相当于array[i][j]位置的竖向正上方的所有位置
            for (int k = 0; k < i; k++) {
                if (array[k][j] == 1) {
                    return false;
                }
            }
    
            // 判断array[i][j]位置左上斜线是否有其它皇后落点
            for (int k = i - 1,p = j - 1;k >= 0 && p >= 0;k--,p--) {
                if (array[k][p] == 1) {
                    return false;
                }
            }
    
            // 判断array[i][j]位置右上斜线是否有其它皇后落点
            for (int k = i -1,p = j + 1;k >= 0 && p < 8;k--,p++) {
                if (array[k][p] == 1) {
                    return false;
                }
            }
            return true;
        }
        
(1) 第一个皇后进来，在行号row=0，如果行号不超过棋盘最大7，则不会输出最终解，
那么就进入到for循环里面，列号column从0开始，即第一列。此时也就是第一行第一列位置摆放皇后肯定合乎要求，
能放下皇后，因为还没有任何其他皇后来干扰。

(2) d对于以上代码，在judgeLegal方法通过了之后，在if里面又会调用一下自己（即递归），row加了1，表示摆第二行摆放第二个皇后了。
第二行的皇后在走for循环的时候，分两种情况：
- 第一种情况：for循环没走到头时就有通过check方法的了，
那么这样就顺理成章地往下走再调用一下自己（即进行深度优先，继续往下递归），row再加1（即摆第三行的皇后了，以此类推）。
- 第二种情况：for循环走完了都没有通过judgeLegal方法，说明第二行根本没有第二个皇后摆放的位置，就无法触发下一层递归，那
下面的第三行第三个皇后等等后面都无法进行下去，所以此时则回溯到上一层第一行皇后位置for循环处进行列数column加1（即进行广度优先遍历，按列横向移动），
即第一行的皇后往后移一格，摆在第一行第二列的位置上，然后又进行深度优先遍历往下走，即重复第一种情况。

(3) 需要注意的是：回溯的时候一定要进行清零的操作，它只有在皇后摆不下去的时候会执行清0的动作（避免脏数据干扰），
如果皇后摆放很顺利的话，对于一个解法来说，从头到尾是不会走这个清0的动作的。

## 完整代码实现

    public class QueensOfEight {

        // 定义一个8*8的棋盘
        public static int[][] array = new int[8][8];
        // 记录总的解法
        public static int count = 0;
    
        /**
         * 得到皇后的解（回溯递归核心实现）
         * @param i 行数
         *
         * 该方法没有返回：因为执行结果有两种
         *          1、要么是得到解并输出后，也会回溯到上一层，进行广度优先寻找其它解
         *          2、要么就是执行完循环后也没有得到解，则方法结束回溯到上一层寻找其它解
         */
        public void getResultQueensOfEight(int i){
            // 满足条件的解
            if (i > 7) {
                count++;
                printResult();
                // 如果只需要获取一个解，不是所有可能的解，则可以在这里做处理
                // return;
            }else {
                // 该层循环的意义：为了获取全部的正确解，进行广度优先遍历：在棋盘中按每行横向移动，找出所有解
                for (int k = 0; k < 8; k++) {
                    // 进行是否有资格进行下一层次递归的判断
                    if (judgeLegal(i, k)) {
                        // 落点合规，设置该回溯点为1
                        array[i][k] = 1;
                        // 进行下一层递归，进行深度优先遍历
                        getResultQueensOfEight(i + 1);
                        // 回溯:寻找其它解，清除状态，设置回溯点状态为0
                        array[i][k] = 0;
                    }
                }
            }
        }
    
        private void printResult() {
            System.out.println("解法"+ count + ":");
            for (int i = 0; i < 8; i++) {
                for (int j = 0;j < 8; j++) {
                    if (array[i][j] == 1) {
                        System.out.print("1");
                    } else {
                        System.out.print("0");
                    }
                }
                System.out.println();
            }
            System.out.println();
        }
    
        /**
         * 进行深层次递归的判断：落点是否合规
         * @param i : 行数
         * @param j : 列数
         * @return
         */
        public boolean judgeLegal(int i, int j){
            // 判断j列是否有另一个皇后已经落点，只需判断j列0到i行的棋盘落点，相当于array[i][j]位置的竖向正上方的所有位置
            for (int k = 0; k < i; k++) {
                if (array[k][j] == 1) {
                    return false;
                }
            }
    
            // 判断array[i][j]位置左上斜线是否有其它皇后落点
            for (int k = i - 1,p = j - 1;k >= 0 && p >= 0;k--,p--) {
                if (array[k][p] == 1) {
                    return false;
                }
            }
    
            // 判断array[i][j]位置右上斜线是否有其它皇后落点
            for (int k = i -1,p = j + 1;k >= 0 && p < 8;k--,p++) {
                if (array[k][p] == 1) {
                    return false;
                }
            }
            return true;
        }
    
        public static void main(String[] args) {
            new QueensOfEight().getResultQueensOfEight(0);
        } 
     }          
